{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart Guide","text":"<p>The Systematic Trading Toolkit (STTK) is a set of open source modules that support quantitative research and the development and execution of systematic trading strategies. This Quickstart Guide will introduce you to some of the key features of the toolkit.</p>"},{"location":"architecture/core-idea/","title":"Core Idea","text":""},{"location":"architecture/core-idea/#introduction-to-event-driven-architecture","title":"Introduction to Event-driven Architecture","text":"<p>Event-Driven Architecture (EDA) is a design paradigm in which system components asynchronously respond to significant occurrences, termed events. An event represents a notable change in the internal state of a system or an external stimulus. In EDA, components are designed to monitor these events and execute appropriate actions in response. Within trading systems, examples of such events include (system external) market events, such as a newly received price tick from an API, or (system internal) signal events, such as the generation of a buy or sell signal based on a certain price-related conditions. Importantly, responses to events may themselves trigger new events, forming a dynamic, reactive system.</p> <p>An event-driven system typically consists of three core components: event emitters, event consumers, and an event channel. Event emitters (also called producers) generate events. These changes are encapsulated in event messages, which are data packets describing the event type and associated information. Event consumers (also called sinks) process these event messages, executing tasks such as sending orders to a broker or updating a database. The event channel (or queue) is essential because it mediates this flow of messages asynchronously, ensuring producers and consumers remain decoupled. Asynchrony here refers to the fact that event emitters do not have to wait for consumers to process their events before generating new ones. Instead, event messages are placed in a queue, where consumers retrieve and process them independently.</p> <p>In an event-driven architecture, the decoupling of event producers and consumers enhances both scalability and maintainability in trading systems. By separating these components, the system gains the flexibility to introduce new modules\u2014such as additional market data feeds or trading algorithms\u2014without disrupting existing workflows. This modularity also improves maintainability: individual components can be updated, replaced, or scaled independently of one another. As a result, the architecture remains adaptable to evolving requirements and is resilient to change, minimizing the need for large-scale system overhauls or disruptions.</p>"},{"location":"architecture/core-idea/#event-classes-and-a-sample-implementation-of-a-tickevent-subclass","title":"Event Classes and a Sample Implementation of a <code>TickEvent</code> Subclass","text":""},{"location":"documentation/documentation/","title":"Documentation","text":""}]}