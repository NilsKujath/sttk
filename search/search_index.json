{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Under Construction!</p> <p>The Systematic Trading Toolkit (STTK) supports quantitative research and the development and execution of systematic trading strategies. STTK is still a work in progress, but don\u2019t worry\u2014a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"documentation/intro_backbone/","title":"Introduction: Event-driven Architecture as the Backbone of (Modern) Trading Infrastructure","text":"<pre><code>while True:\n    pass\n</code></pre>"},{"location":"documentation/notes/","title":"Core Idea","text":""},{"location":"documentation/notes/#introduction-to-event-driven-architecture","title":"Introduction to Event-driven Architecture","text":"<p>Event-Driven Architecture (EDA) is a design paradigm in which system components asynchronously respond to significant occurrences, termed events. An event represents a notable change in the internal state of a system or an external stimulus. In EDA, components are designed to monitor these events and execute appropriate actions in response. Within trading systems, examples of such events include (system external) market events, such as a newly received price tick from an API, or (system internal) signal events, such as the generation of a buy or sell signal based on a certain price-related conditions. Importantly, responses to events may themselves trigger new events, forming a dynamic system.</p> <p>An event-driven system typically consists of three core components: event emitters, event consumers, and an event channel.</p> <ul> <li>Event emitters (also called producers) generate events. These changes are encapsulated in event messages, which are data packets describing the event type and associated information.</li> <li>Event consumers (also called sinks) process these event messages and react to them, which in the context of a trading system could be the execution of tasks such as sending orders to a broker or updating a database.</li> <li>The event channel (or queue) is essential because it mediates this flow of messages asynchronously, ensuring producers and consumers remain decoupled. Asynchrony here refers to the fact that event emitters do not have to wait for consumers to process their events before generating new ones. Instead, event messages are placed in a queue, where consumers retrieve and process them independently.</li> </ul> <p>In an event-driven architecture, the decoupling of event producers and consumers enhances both scalability and maintainability in trading systems: individual components can be updated, replaced, or scaled independently of one another. As a result, the architecture remains adaptable to evolving requirements and is resilient to change, minimizing the need for large-scale system overhauls or disruptions.</p>"},{"location":"documentation/notes/#event-class-and-a-sample-implementation-of-a-tickevent-subclass","title":"<code>Event</code> Class and a Sample Implementation of a <code>TickEvent</code> Subclass","text":"<p>In an event-driven system, the <code>Event</code> class defines the structure of event messages\u2014data packets that convey important occurrences, such as market price changes or trading signals. These messages are processed by the system to trigger appropriate actions. By subclassing the <code>Event</code> class, we can create specialized types of event messages, such as a <code>TickEvent</code> for tick data updates or a <code>SignalEvent</code> for buy/sell signals, each carrying the specific information relevant to processing that event. This approach ensures uniformity throughout the system while allowing new types of event messages to be easily integrated as needed.</p> <p>The <code>abc</code> module (Abstract Base Classes) in Python enforces structure and consistency by defining the <code>Event</code> class as an abstract base class (ABC). This ensures that all specific event types, such as <code>TickEvent</code> or <code>SignalEvent</code>, conform to a common interface. The <code>Event</code> class acts as a blueprint, preventing direct instantiation and requiring subclasses to implement the necessary methods and properties. By using ABCs, the system ensures that event subclasses are correctly implemented before being used, promoting reliability and uniformity across the architecture. This design makes it easy to extend the system with new event types while maintaining robust interactions between components.</p> <pre><code>import datetime\nimport logging\nfrom abc import ABC, abstractmethod\n\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\n\n# -------------------\n# Event Classes\n# -------------------\n\nclass Event(ABC):\n    def __init__(self, event_type: str) -&gt; None:\n        self.event_type: str = event_type\n\n    @abstractmethod\n    def log_event(self) -&gt; None:\n        pass\n\n\nclass TickEvent(Event):\n    def __init__(\n        self, symbol: str, time: datetime.datetime, bid: float, ask: float\n    ) -&gt; None:\n        super().__init__(event_type=\"TICK\")\n        self.symbol: str = symbol\n        self.time: datetime.datetime = time\n        self.bid: float = bid\n        self.ask: float = ask\n\n    def log_event(self) -&gt; None:\n        logging.info(\n            f\"TickEvent - Symbol: {self.symbol}, Time: {self.time}, \"\n            f\"Bid: {self.bid:.5f}, Ask: {self.ask:.5f}\"\n        )\n</code></pre>"},{"location":"documentation/notes/#implementing-an-event-channel-with-pythons-queue-module","title":"Implementing an Event Channel with Python's <code>queue</code> Module","text":"<p>Python's <code>queue</code> module serves as a central mechanism for managing the asynchronous flow of events between producers and consumers. This module provides the underlying structure that allows different components of a system to communicate and exchange data efficiently while remaining decoupled from each other. The core purpose of the <code>queue</code> module is to provide a thread-safe (i.e., safe for concurrent use by multiple threads without causing data corruption), first-in-first-out (FIFO) data structure that allows multiple producers to enqueue items and multiple consumers to dequeue and process them simultaneously without interfering with each other's operations. This decoupling is essential for designing modular and scalable systems capable of managing high-frequency data flows, such as market tick data, while ensuring that events are processed in their exact temporal order to maintain the integrity and accuracy of downstream trading logic.</p>"},{"location":"documentation/ontology-of-event-types/","title":"Ontology of Event Types","text":""}]}